import fs from 'node:fs';
import path from 'node:path';

import { goSync } from '@api3/promise-utils';
import { format } from 'prettier';

import { type Dapp, dappSchema } from '../src/types';

const PRETTIER_CONFIG = path.join(__dirname, '..', '.prettierrc');
const INPUT_DIR = path.join(__dirname, '..', 'data', 'dapps');
const OUTPUT_DIR = path.join(__dirname, '..', 'src', 'generated');
const OUTPUT_FILE = path.join(OUTPUT_DIR, 'dapps.ts');

const HEADER_CONTENT = `// ===========================================================================
// DO NOT EDIT THIS FILE MANUALLY!
//
// The contents have been added automatically.
// See: scripts/generate-dapps.ts for more information
// ===========================================================================

import { type Dapp } from '../types';
`;

function ensureMorphoDappConventions(fileContent: Dapp) {
  const { aliases } = fileContent;

  for (const [alias, dapp] of Object.entries(aliases)) {
    // Abort the validation for special cased aliases.
    if (alias === 'feather' || alias === 'morpho-api3') continue;

    // Verify basic alias and title format.
    const aSplit = alias.split('-'); // e.g. morpho-mvl-usdc-770-lltv
    const tSplit = dapp.title.split(/[ /]/); // e.g. Morpho MVL/USDC 77% LLTV
    if (aSplit.length !== 5) throw new Error(`Morpho alias ${alias} has an invalid format.`);
    if (tSplit.length !== 5) throw new Error(`Morpho title ${dapp.title} has an invalid format.`);
    const [aMorphoStr, aCollateralToken, aBorrowToken, aLltv, aLltvStr] = aSplit;
    const [tMorphoStr, tCollateralToken, tBorrowToken, tLltv, tLltvStr] = tSplit;

    // Verify the title/alias convention.
    if (
      aMorphoStr !== 'morpho' ||
      tMorphoStr !== 'Morpho' ||
      aCollateralToken !== tCollateralToken!.toLowerCase() || // The token names are sometimes mixed case, e.g. wstETH
      aBorrowToken !== tBorrowToken!.toLowerCase() || // The token names are sometimes mixed case, e.g. wstETH
      `${Number(aLltv) / 10}%` !== tLltv ||
      aLltvStr!.toUpperCase() !== tLltvStr
    ) {
      throw new Error(`Morpho title/alias discrepancy for alias: ${alias}`);
    }

    // Verify the title/description convention.
    const expectedDescription = `Only to be used for the ${tCollateralToken}/${tBorrowToken} ${tLltv} LLTV market.`;
    if (dapp.description !== expectedDescription) {
      throw new Error(`Morpho title/description discrepancy for alias: ${alias}`);
    }
  }
}

async function main(): Promise<void> {
  const fileNames = fs.readdirSync(INPUT_DIR);
  const jsonFiles = fileNames.filter((fileName) => fileName.endsWith('.json'));
  const combinedDapps: any = [];

  for (const jsonFile of jsonFiles) {
    const filePath = path.join(INPUT_DIR, jsonFile);
    const goFileContent = goSync(() => dappSchema.parse(JSON.parse(fs.readFileSync(filePath, 'utf8'))));
    if (!goFileContent.success) {
      throw new Error(`Invalid dApps file content: ${filePath}\n${goFileContent.error}`);
    }
    const fileContent = goFileContent.data;

    // Apply custom validation for non-schema enforced conventions.
    switch (jsonFile) {
      case 'morpho.json': {
        ensureMorphoDappConventions(fileContent);
        break;
      }
      default: {
        break;
      }
    }

    combinedDapps.push(fileContent);
  }

  const aliases = combinedDapps.flatMap((dapp: any) => Object.keys(dapp.aliases));
  if (aliases.length !== new Set(aliases).size) {
    throw new Error(`Duplicate dApp aliases found. See:\n${JSON.stringify(aliases.sort(), null, 2)}`);
  }

  const rawContent = `${HEADER_CONTENT}\nexport const DAPPS: Dapp[] = ${JSON.stringify(combinedDapps)};\n\n`;

  const prettierConfig = JSON.parse(fs.readFileSync(PRETTIER_CONFIG, 'utf8'));
  const formattedContent = await format(rawContent, { ...prettierConfig, parser: 'typescript' });

  if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR);
  }

  fs.writeFileSync(OUTPUT_FILE, formattedContent);
  // eslint-disable-next-line no-console
  console.log(`Combined dApps been saved as ${OUTPUT_FILE}`);
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    // eslint-disable-next-line no-console
    console.log(error);
    process.exit(1);
  });
